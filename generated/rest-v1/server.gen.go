// Package rest_v1 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.11.0 DO NOT EDIT.
package rest_v1

import (
	"fmt"
	"net/http"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// get app info
	// (GET /)
	GetAppInfo(ctx echo.Context, params GetAppInfoParams) error
	// upload file
	// (POST /file)
	UploadFile(ctx echo.Context, params UploadFileParams) error
	// retrieve file
	// (GET /file/{slug})
	RetrieveFileBySlug(ctx echo.Context, slug ObjectSlug, params RetrieveFileBySlugParams) error
	// create auth client
	// (POST /v1/auth-client)
	CreateAuthClient(ctx echo.Context, params CreateAuthClientParams) error
	// search auth client
	// (POST /v1/auth-client/search)
	SearchAuthClient(ctx echo.Context, params SearchAuthClientParams) error
	// get auth client
	// (GET /v1/auth-client/{id})
	GetAuthClientById(ctx echo.Context, id ObjectId, params GetAuthClientByIdParams) error
	// update auth client
	// (PUT /v1/auth-client/{id})
	UpdateAuthClientById(ctx echo.Context, id ObjectId, params UpdateAuthClientByIdParams) error
	// create barrel
	// (POST /v1/barrel)
	CreateBarrel(ctx echo.Context, params CreateBarrelParams) error
	// search barrel
	// (POST /v1/barrel/search)
	SearchBarrel(ctx echo.Context, params SearchBarrelParams) error
	// get barrel
	// (GET /v1/barrel/{id})
	GetBarrelById(ctx echo.Context, id ObjectId, params GetBarrelByIdParams) error
	// update barrel
	// (PUT /v1/barrel/{id})
	UpdateBarrelById(ctx echo.Context, id ObjectId, params UpdateBarrelByIdParams) error
	// search file
	// (POST /v1/file/search)
	SearchFile(ctx echo.Context, params SearchFileParams) error
	// delete file
	// (DELETE /v1/file/{id})
	DeleteFileById(ctx echo.Context, id ObjectId, params DeleteFileByIdParams) error
	// get file
	// (GET /v1/file/{id})
	GetFileById(ctx echo.Context, id ObjectId, params GetFileByIdParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetAppInfo converts echo context to params.
func (w *ServerInterfaceWrapper) GetAppInfo(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAppInfoParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Correlation-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Correlation-Id")]; found {
		var XCorrelationId CorrelationId
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Correlation-Id, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Correlation-Id", runtime.ParamLocationHeader, valueList[0], &XCorrelationId)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Correlation-Id: %s", err))
		}

		params.XCorrelationId = &XCorrelationId
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAppInfo(ctx, params)
	return err
}

// UploadFile converts echo context to params.
func (w *ServerInterfaceWrapper) UploadFile(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params UploadFileParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Correlation-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Correlation-Id")]; found {
		var XCorrelationId CorrelationId
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Correlation-Id, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Correlation-Id", runtime.ParamLocationHeader, valueList[0], &XCorrelationId)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Correlation-Id: %s", err))
		}

		params.XCorrelationId = &XCorrelationId
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UploadFile(ctx, params)
	return err
}

// RetrieveFileBySlug converts echo context to params.
func (w *ServerInterfaceWrapper) RetrieveFileBySlug(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "slug" -------------
	var slug ObjectSlug

	err = runtime.BindStyledParameterWithLocation("simple", false, "slug", runtime.ParamLocationPath, ctx.Param("slug"), &slug)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter slug: %s", err))
	}

	ctx.Set(BasicAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params RetrieveFileBySlugParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Correlation-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Correlation-Id")]; found {
		var XCorrelationId CorrelationId
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Correlation-Id, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Correlation-Id", runtime.ParamLocationHeader, valueList[0], &XCorrelationId)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Correlation-Id: %s", err))
		}

		params.XCorrelationId = &XCorrelationId
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RetrieveFileBySlug(ctx, slug, params)
	return err
}

// CreateAuthClient converts echo context to params.
func (w *ServerInterfaceWrapper) CreateAuthClient(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateAuthClientParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Correlation-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Correlation-Id")]; found {
		var XCorrelationId CorrelationId
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Correlation-Id, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Correlation-Id", runtime.ParamLocationHeader, valueList[0], &XCorrelationId)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Correlation-Id: %s", err))
		}

		params.XCorrelationId = &XCorrelationId
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateAuthClient(ctx, params)
	return err
}

// SearchAuthClient converts echo context to params.
func (w *ServerInterfaceWrapper) SearchAuthClient(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchAuthClientParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Correlation-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Correlation-Id")]; found {
		var XCorrelationId CorrelationId
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Correlation-Id, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Correlation-Id", runtime.ParamLocationHeader, valueList[0], &XCorrelationId)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Correlation-Id: %s", err))
		}

		params.XCorrelationId = &XCorrelationId
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchAuthClient(ctx, params)
	return err
}

// GetAuthClientById converts echo context to params.
func (w *ServerInterfaceWrapper) GetAuthClientById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id ObjectId

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BasicAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAuthClientByIdParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Correlation-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Correlation-Id")]; found {
		var XCorrelationId CorrelationId
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Correlation-Id, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Correlation-Id", runtime.ParamLocationHeader, valueList[0], &XCorrelationId)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Correlation-Id: %s", err))
		}

		params.XCorrelationId = &XCorrelationId
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAuthClientById(ctx, id, params)
	return err
}

// UpdateAuthClientById converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateAuthClientById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id ObjectId

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BasicAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params UpdateAuthClientByIdParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Correlation-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Correlation-Id")]; found {
		var XCorrelationId CorrelationId
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Correlation-Id, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Correlation-Id", runtime.ParamLocationHeader, valueList[0], &XCorrelationId)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Correlation-Id: %s", err))
		}

		params.XCorrelationId = &XCorrelationId
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UpdateAuthClientById(ctx, id, params)
	return err
}

// CreateBarrel converts echo context to params.
func (w *ServerInterfaceWrapper) CreateBarrel(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateBarrelParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Correlation-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Correlation-Id")]; found {
		var XCorrelationId CorrelationId
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Correlation-Id, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Correlation-Id", runtime.ParamLocationHeader, valueList[0], &XCorrelationId)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Correlation-Id: %s", err))
		}

		params.XCorrelationId = &XCorrelationId
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateBarrel(ctx, params)
	return err
}

// SearchBarrel converts echo context to params.
func (w *ServerInterfaceWrapper) SearchBarrel(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchBarrelParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Correlation-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Correlation-Id")]; found {
		var XCorrelationId CorrelationId
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Correlation-Id, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Correlation-Id", runtime.ParamLocationHeader, valueList[0], &XCorrelationId)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Correlation-Id: %s", err))
		}

		params.XCorrelationId = &XCorrelationId
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchBarrel(ctx, params)
	return err
}

// GetBarrelById converts echo context to params.
func (w *ServerInterfaceWrapper) GetBarrelById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id ObjectId

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BasicAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBarrelByIdParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Correlation-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Correlation-Id")]; found {
		var XCorrelationId CorrelationId
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Correlation-Id, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Correlation-Id", runtime.ParamLocationHeader, valueList[0], &XCorrelationId)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Correlation-Id: %s", err))
		}

		params.XCorrelationId = &XCorrelationId
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBarrelById(ctx, id, params)
	return err
}

// UpdateBarrelById converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateBarrelById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id ObjectId

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BasicAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params UpdateBarrelByIdParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Correlation-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Correlation-Id")]; found {
		var XCorrelationId CorrelationId
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Correlation-Id, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Correlation-Id", runtime.ParamLocationHeader, valueList[0], &XCorrelationId)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Correlation-Id: %s", err))
		}

		params.XCorrelationId = &XCorrelationId
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UpdateBarrelById(ctx, id, params)
	return err
}

// SearchFile converts echo context to params.
func (w *ServerInterfaceWrapper) SearchFile(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchFileParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Correlation-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Correlation-Id")]; found {
		var XCorrelationId CorrelationId
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Correlation-Id, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Correlation-Id", runtime.ParamLocationHeader, valueList[0], &XCorrelationId)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Correlation-Id: %s", err))
		}

		params.XCorrelationId = &XCorrelationId
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchFile(ctx, params)
	return err
}

// DeleteFileById converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteFileById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id ObjectId

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BasicAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteFileByIdParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Correlation-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Correlation-Id")]; found {
		var XCorrelationId CorrelationId
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Correlation-Id, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Correlation-Id", runtime.ParamLocationHeader, valueList[0], &XCorrelationId)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Correlation-Id: %s", err))
		}

		params.XCorrelationId = &XCorrelationId
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteFileById(ctx, id, params)
	return err
}

// GetFileById converts echo context to params.
func (w *ServerInterfaceWrapper) GetFileById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id ObjectId

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BasicAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFileByIdParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Correlation-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Correlation-Id")]; found {
		var XCorrelationId CorrelationId
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Correlation-Id, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Correlation-Id", runtime.ParamLocationHeader, valueList[0], &XCorrelationId)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Correlation-Id: %s", err))
		}

		params.XCorrelationId = &XCorrelationId
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetFileById(ctx, id, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/", wrapper.GetAppInfo)
	router.POST(baseURL+"/file", wrapper.UploadFile)
	router.GET(baseURL+"/file/:slug", wrapper.RetrieveFileBySlug)
	router.POST(baseURL+"/v1/auth-client", wrapper.CreateAuthClient)
	router.POST(baseURL+"/v1/auth-client/search", wrapper.SearchAuthClient)
	router.GET(baseURL+"/v1/auth-client/:id", wrapper.GetAuthClientById)
	router.PUT(baseURL+"/v1/auth-client/:id", wrapper.UpdateAuthClientById)
	router.POST(baseURL+"/v1/barrel", wrapper.CreateBarrel)
	router.POST(baseURL+"/v1/barrel/search", wrapper.SearchBarrel)
	router.GET(baseURL+"/v1/barrel/:id", wrapper.GetBarrelById)
	router.PUT(baseURL+"/v1/barrel/:id", wrapper.UpdateBarrelById)
	router.POST(baseURL+"/v1/file/search", wrapper.SearchFile)
	router.DELETE(baseURL+"/v1/file/:id", wrapper.DeleteFileById)
	router.GET(baseURL+"/v1/file/:id", wrapper.GetFileById)

}
